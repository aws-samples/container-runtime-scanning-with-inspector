"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_ecs_1 = require("@aws-sdk/client-ecs");
const ecs = new client_ecs_1.ECSClient({});
// returns list of cluster ARN
const getListOfClusterARN = async () => {
    let clusterList = [];
    let nextToken;
    const input = {};
    const command = new client_ecs_1.ListClustersCommand(input);
    do {
        const response = await ecs.send(command);
        if (response != undefined) {
            nextToken = response.nextToken;
            clusterList = clusterList.concat(response.clusterArns);
        }
    } while (nextToken);
    return clusterList;
};
// returns list of ALL task ARN from specified cluster
const listTasksFromClusterARN = async (clusterName) => {
    let taskList = [];
    let nextToken;
    do {
        const input = {
            cluster: clusterName,
        };
        const command = new client_ecs_1.ListTasksCommand(input);
        const response = await ecs.send(command);
        if (response === undefined) {
            return undefined;
        }
        else {
            nextToken = response.nextToken;
            if (response.taskArns != undefined) {
                taskList = taskList.concat(response.taskArns);
            }
        }
    } while (nextToken);
    return taskList;
};
// formats task ARN to ID
const formatTaskName = (taskARN) => {
    const indexOfLastSlash = taskARN.lastIndexOf("/");
    const taskName = taskARN.substring(indexOfLastSlash + 1);
    return taskName;
};
const chunkArray = (array, chunkSize) => {
    const chunks = [];
    let index = 0;
    while (index < array.length) {
        chunks.push(array.slice(index, index + chunkSize));
        index += chunkSize;
    }
    return chunks;
};
const getTaskDescriptions = async (clusterARN, taskIdList) => {
    if (taskIdList.length <= 100) {
        const input = {
            tasks: taskIdList,
            cluster: clusterARN,
        };
        const command = new client_ecs_1.DescribeTasksCommand(input);
        const response = await ecs.send(command);
        if (response != undefined) {
            return response.tasks;
        }
    }
    else {
        const taskChunks = chunkArray(taskIdList, 100);
        let taskDescriptions = [];
        for (const taskChunk of taskChunks) {
            const input = {
                tasks: taskChunk,
                cluster: clusterARN,
            };
            const command = new client_ecs_1.DescribeTasksCommand(input);
            const response = await ecs.send(command);
            if (response != undefined) {
                taskDescriptions = taskDescriptions.concat(response.tasks);
            }
        }
        return taskDescriptions;
    }
    return undefined;
};
// compares event image digest with task image digest
const compareDigests = (eventImageDigest, imageDigest) => {
    return eventImageDigest === imageDigest;
};
// gets all task descriptions from all clusters
const getAllTaskDescriptions = async (clusterARNs) => {
    let returnTaskList = [];
    for (const cluster of clusterARNs) {
        const taskIds = await listTasksFromClusterARN(cluster);
        if (taskIds != undefined) {
            const taskDescriptions = await getTaskDescriptions(cluster, taskIds);
            if (taskDescriptions != undefined) {
                returnTaskList = returnTaskList.concat(taskDescriptions);
            }
        }
        else {
            return undefined;
        }
    }
    return returnTaskList;
};
// main lambda function
const handler = async function (event, context, callback) {
    const eventImageARN = event.resources[0];
    const eventImageARNDigestIndex = eventImageARN.lastIndexOf("/sha256:");
    const eventImageDigest = eventImageARN.slice(eventImageARNDigestIndex + 1);
    const clusterList = await getListOfClusterARN();
    const allTasks = await getAllTaskDescriptions(clusterList);
    if (allTasks != undefined) {
        for (const task of allTasks) {
            if (task.containers) {
                for (const container of task.containers) {
                    if (compareDigests(container.imageDigest, eventImageDigest)) {
                        console.log(`Container: ${container.name} has been found to have a new vulnerability. The associated image can be found here: ${container.image}`);
                    }
                }
            }
        }
    }
};
exports.handler = handler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxvREFPNkI7QUFFN0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxzQkFBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBRTlCLDhCQUE4QjtBQUM5QixNQUFNLG1CQUFtQixHQUFHLEtBQUssSUFBdUIsRUFBRTtJQUN4RCxJQUFJLFdBQVcsR0FBYSxFQUFFLENBQUM7SUFDL0IsSUFBSSxTQUE2QixDQUFDO0lBRWxDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQztJQUNqQixNQUFNLE9BQU8sR0FBRyxJQUFJLGdDQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9DLEdBQUc7UUFDRCxNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsSUFBSSxRQUFRLElBQUksU0FBUyxFQUFFO1lBQ3pCLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO1lBQy9CLFdBQVcsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFZLENBQUMsQ0FBQztTQUN6RDtLQUNGLFFBQVEsU0FBUyxFQUFFO0lBQ3BCLE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLHNEQUFzRDtBQUN0RCxNQUFNLHVCQUF1QixHQUFHLEtBQUssRUFBRSxXQUFtQixFQUFFLEVBQUU7SUFDNUQsSUFBSSxRQUFRLEdBQWEsRUFBRSxDQUFDO0lBQzVCLElBQUksU0FBNkIsQ0FBQztJQUVsQyxHQUFHO1FBQ0QsTUFBTSxLQUFLLEdBQUc7WUFDWixPQUFPLEVBQUUsV0FBVztTQUNyQixDQUFDO1FBQ0YsTUFBTSxPQUFPLEdBQUcsSUFBSSw2QkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QyxNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7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RUFBRTtvQkFDeEMsSUFBSSxjQUFjLENBQUMsU0FBUyxDQUFDLFdBQVksRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFO3dCQUM1RCxPQUFPLENBQUMsR0FBRyxDQUNULGNBQWMsU0FBUyxDQUFDLElBQUksd0ZBQXdGLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FDdEksQ0FBQztxQkFDSDtpQkFDRjthQUNGO1NBQ0Y7S0FDRjtBQUNILENBQUMsQ0FBQztBQXhCVyxRQUFBLE9BQU8sV0F3QmxCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FsbGJhY2ssIEV2ZW50QnJpZGdlRXZlbnQsIENvbnRleHQgfSBmcm9tIFwiYXdzLWxhbWJkYVwiO1xuaW1wb3J0IHtcbiAgRUNTQ2xpZW50LFxuICBMaXN0Q2x1c3RlcnNDb21tYW5kLFxuICBMaXN0VGFza3NDb21tYW5kLFxuICBEZXNjcmliZVRhc2tzQ29tbWFuZCxcbiAgRGVzY3JpYmVDbHVzdGVyc0NvbW1hbmQsXG4gIFRhc2ssXG59IGZyb20gXCJAYXdzLXNkay9jbGllbnQtZWNzXCI7XG5cbmNvbnN0IGVjcyA9IG5ldyBFQ1NDbGllbnQoe30pO1xuXG4vLyByZXR1cm5zIGxpc3Qgb2YgY2x1c3RlciBBUk5cbmNvbnN0IGdldExpc3RPZkNsdXN0ZXJBUk4gPSBhc3luYyAoKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICBsZXQgY2x1c3Rlckxpc3Q6IHN0cmluZ1tdID0gW107XG4gIGxldCBuZXh0VG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBjb25zdCBpbnB1dCA9IHt9O1xuICBjb25zdCBjb21tYW5kID0gbmV3IExpc3RDbHVzdGVyc0NvbW1hbmQoaW5wdXQpO1xuICBkbyB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlY3Muc2VuZChjb21tYW5kKTtcbiAgICBpZiAocmVzcG9uc2UgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXh0VG9rZW4gPSByZXNwb25zZS5uZXh0VG9rZW47XG4gICAgICBjbHVzdGVyTGlzdCA9IGNsdXN0ZXJMaXN0LmNvbmNhdChyZXNwb25zZS5jbHVzdGVyQXJucyEpO1xuICAgIH1cbiAgfSB3aGlsZSAobmV4dFRva2VuKTtcbiAgcmV0dXJuIGNsdXN0ZXJMaXN0O1xufTtcblxuLy8gcmV0dXJucyBsaXN0IG9mIEFMTCB0YXNrIEFSTiBmcm9tIHNwZWNpZmllZCBjbHVzdGVyXG5jb25zdCBsaXN0VGFza3NGcm9tQ2x1c3RlckFSTiA9IGFzeW5jIChjbHVzdGVyTmFtZTogc3RyaW5nKSA9PiB7XG4gIGxldCB0YXNrTGlzdDogc3RyaW5nW10gPSBbXTtcbiAgbGV0IG5leHRUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIGRvIHtcbiAgICBjb25zdCBpbnB1dCA9IHtcbiAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgIH07XG4gICAgY29uc3QgY29tbWFuZCA9IG5ldyBMaXN0VGFza3NDb21tYW5kKGlucHV0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGVjcy5zZW5kKGNvbW1hbmQpO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0VG9rZW4gPSByZXNwb25zZS5uZXh0VG9rZW47XG4gICAgICBpZiAocmVzcG9uc2UudGFza0FybnMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhc2tMaXN0ID0gdGFza0xpc3QuY29uY2F0KHJlc3BvbnNlLnRhc2tBcm5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5leHRUb2tlbik7XG4gIHJldHVybiB0YXNrTGlzdDtcbn07XG5cbi8vIGZvcm1hdHMgdGFzayBBUk4gdG8gSURcbmNvbnN0IGZvcm1hdFRhc2tOYW1lID0gKHRhc2tBUk46IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGluZGV4T2ZMYXN0U2xhc2ggPSB0YXNrQVJOLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgY29uc3QgdGFza05hbWUgPSB0YXNrQVJOLnN1YnN0cmluZyhpbmRleE9mTGFzdFNsYXNoICsgMSk7XG4gIHJldHVybiB0YXNrTmFtZTtcbn07XG5cbmNvbnN0IGNodW5rQXJyYXkgPSAoYXJyYXk6IGFueVtdLCBjaHVua1NpemU6IG51bWJlcik6IGFueVtdW10gPT4ge1xuICBjb25zdCBjaHVua3M6IGFueVtdW10gPSBbXTtcbiAgbGV0IGluZGV4ID0gMFxuICB3aGlsZSAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpbmRleCwgaW5kZXggKyBjaHVua1NpemUpKTtcbiAgICBpbmRleCArPSBjaHVua1NpemU7XG4gIH1cbiAgcmV0dXJuIGNodW5rcztcbn1cblxuY29uc3QgZ2V0VGFza0Rlc2NyaXB0aW9ucyA9IGFzeW5jIChcbiAgY2x1c3RlckFSTjogc3RyaW5nLFxuICB0YXNrSWRMaXN0OiBzdHJpbmdbXVxuKTogUHJvbWlzZTxUYXNrW10gfCB1bmRlZmluZWQ+ID0+IHtcbiAgaWYgKHRhc2tJZExpc3QubGVuZ3RoIDw9IDEwMCkge1xuICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgdGFza3M6IHRhc2tJZExpc3QsXG4gICAgICBjbHVzdGVyOiBjbHVzdGVyQVJOLFxuICAgIH07XG4gICAgY29uc3QgY29tbWFuZCA9IG5ldyBEZXNjcmliZVRhc2tzQ29tbWFuZChpbnB1dCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlY3Muc2VuZChjb21tYW5kKTtcbiAgICBpZiAocmVzcG9uc2UgIT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGFza3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhc2tDaHVua3MgPSBjaHVua0FycmF5KHRhc2tJZExpc3QsIDEwMCk7XG4gICAgbGV0IHRhc2tEZXNjcmlwdGlvbnM6IFRhc2tbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFza0NodW5rIG9mIHRhc2tDaHVua3MpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgICB0YXNrczogdGFza0NodW5rLFxuICAgICAgICBjbHVzdGVyOiBjbHVzdGVyQVJOLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgRGVzY3JpYmVUYXNrc0NvbW1hbmQoaW5wdXQpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlY3Muc2VuZChjb21tYW5kKTtcbiAgICAgIGlmIChyZXNwb25zZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFza0Rlc2NyaXB0aW9ucyA9IHRhc2tEZXNjcmlwdGlvbnMuY29uY2F0KHJlc3BvbnNlLnRhc2tzISk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXNrRGVzY3JpcHRpb25zO1xuICB9IFxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gY29tcGFyZXMgZXZlbnQgaW1hZ2UgZGlnZXN0IHdpdGggdGFzayBpbWFnZSBkaWdlc3RcbmNvbnN0IGNvbXBhcmVEaWdlc3RzID0gKFxuICBldmVudEltYWdlRGlnZXN0OiBzdHJpbmcsXG4gIGltYWdlRGlnZXN0OiBzdHJpbmdcbik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gZXZlbnRJbWFnZURpZ2VzdCA9PT0gaW1hZ2VEaWdlc3Q7XG59O1xuXG4vLyBnZXRzIGFsbCB0YXNrIGRlc2NyaXB0aW9ucyBmcm9tIGFsbCBjbHVzdGVyc1xuY29uc3QgZ2V0QWxsVGFza0Rlc2NyaXB0aW9ucyA9IGFzeW5jIChjbHVzdGVyQVJOczogc3RyaW5nW10pOiBQcm9taXNlPFRhc2tbXSB8IHVuZGVmaW5lZD4gPT4ge1xuICBsZXQgcmV0dXJuVGFza0xpc3Q6IFRhc2tbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGNsdXN0ZXIgb2YgY2x1c3RlckFSTnMpIHtcbiAgICBjb25zdCB0YXNrSWRzID0gYXdhaXQgbGlzdFRhc2tzRnJvbUNsdXN0ZXJBUk4oY2x1c3Rlcik7IFxuICAgIGlmICh0YXNrSWRzICE9IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFza0Rlc2NyaXB0aW9ucyA9IGF3YWl0IGdldFRhc2tEZXNjcmlwdGlvbnMoY2x1c3RlciwgdGFza0lkcyk7IFxuICAgICAgaWYgKHRhc2tEZXNjcmlwdGlvbnMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVyblRhc2tMaXN0ID0gcmV0dXJuVGFza0xpc3QuY29uY2F0KHRhc2tEZXNjcmlwdGlvbnMhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIHJldHVyblRhc2tMaXN0O1xufVxuXG5cbi8vIG1haW4gbGFtYmRhIGZ1bmN0aW9uXG5leHBvcnQgY29uc3QgaGFuZGxlciA9IGFzeW5jIGZ1bmN0aW9uIChcbiAgZXZlbnQ6IEV2ZW50QnJpZGdlRXZlbnQ8c3RyaW5nLCBhbnk+LFxuICBjb250ZXh0OiBDb250ZXh0LFxuICBjYWxsYmFjazogQ2FsbGJhY2tcbikge1xuICBjb25zdCBldmVudEltYWdlQVJOOiBzdHJpbmcgPSBldmVudC5yZXNvdXJjZXNbMF07XG4gIGNvbnN0IGV2ZW50SW1hZ2VBUk5EaWdlc3RJbmRleCA9IGV2ZW50SW1hZ2VBUk4ubGFzdEluZGV4T2YoXCIvc2hhMjU2OlwiKTtcbiAgY29uc3QgZXZlbnRJbWFnZURpZ2VzdCA9IGV2ZW50SW1hZ2VBUk4uc2xpY2UoZXZlbnRJbWFnZUFSTkRpZ2VzdEluZGV4ICsgMSk7XG5cbiAgY29uc3QgY2x1c3Rlckxpc3QgPSBhd2FpdCBnZXRMaXN0T2ZDbHVzdGVyQVJOKCk7IFxuICBjb25zdCBhbGxUYXNrcyA9IGF3YWl0IGdldEFsbFRhc2tEZXNjcmlwdGlvbnMoY2x1c3Rlckxpc3QpOyBcbiAgaWYgKGFsbFRhc2tzICE9IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdGFzayBvZiBhbGxUYXNrcyEpIHtcbiAgICAgIGlmICh0YXNrLmNvbnRhaW5lcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGFzay5jb250YWluZXJzISkge1xuICAgICAgICAgIGlmIChjb21wYXJlRGlnZXN0cyhjb250YWluZXIuaW1hZ2VEaWdlc3QhLCBldmVudEltYWdlRGlnZXN0KSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGBDb250YWluZXI6ICR7Y29udGFpbmVyLm5hbWV9IGhhcyBiZWVuIGZvdW5kIHRvIGhhdmUgYSBuZXcgdnVsbmVyYWJpbGl0eS4gVGhlIGFzc29jaWF0ZWQgaW1hZ2UgY2FuIGJlIGZvdW5kIGhlcmU6ICR7Y29udGFpbmVyLmltYWdlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl19