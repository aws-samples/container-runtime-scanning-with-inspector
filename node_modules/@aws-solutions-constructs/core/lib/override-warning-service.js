"use strict";
/**
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance
 *  with the License. A copy of the License is located at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES
 *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions
 *  and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.flagOverriddenDefaults = void 0;
/*
 *  The functions found here in the core library are for internal use and can be changed
 *  or removed outside of a major release. We recommend against calling them directly from client code.
 */
const deepdiff = require("deep-diff");
const utils_1 = require("./utils");
/**
 * @internal This is an internal core function and should not be called directly by Solutions Constructs clients.
 *
 * Emits a warning to the console when a prescriptive default value is overridden by the user.
 * @param {object} defaultProps the prescriptive defaults for the pattern.
 * @param {object} userProps the properties provided by the user, to be compared against the defaultProps.
 */
function flagOverriddenDefaults(defaultProps, userProps) {
    // Compare the properties and return any overrides
    const overrides = findOverrides(defaultProps, userProps);
    // Emit a warning for each override
    for (let i = 0; i < ((overrides !== undefined) ? overrides.length : 0); i++) {
        const e = Object.assign(overrides[i]);
        // Determine appropriate logging granularity
        const valuesAreReadable = (checkReadability(e.lhs) &&
            checkReadability(e.rhs));
        // Format the path for readability
        const path = formatOverridePath(e.path);
        // Output
        const details = (valuesAreReadable) ? ` Default value: '${e.lhs}'. You provided: '${e.rhs}'.` : '';
        utils_1.printWarning(`An override has been provided for the property: ${path}.` + details);
    }
}
exports.flagOverriddenDefaults = flagOverriddenDefaults;
/** The prefilter function returns true for any filtered path/key that should be excluded from the diff check.
 * Any Construct Props using cdk.Duration type is not properly handled by
 * 'deep-diff' library, whenever it encounters a Duration object, it throws the exception
 * 'Argument to Intrinsic must be a plain value object', so such props are excluded from the diff check.
 */
function _prefilter(_path, _key) {
    const prefilters = ['maxRecordAge', 'expiration', 'transitionAfter', 'destination', 'timeout', 'period'];
    if (prefilters.indexOf(_key) >= 0) {
        return true;
    }
    return false;
}
/**
 * Performs a diff check of the userProps against the defaultProps to detect overridden properties.
 * @param {object} defaultProps the prescriptive defaults for the pattern.
 * @param {object} userProps the properties provided by the user, to be compared against the defaultProps.
 * @return {Array} an array containing the overridden values.
 */
function findOverrides(defaultProps, userProps) {
    const diff = deepdiff.diff(defaultProps, userProps, _prefilter);
    // Filter the results
    return (diff !== undefined) ? diff?.filter((e) => (e.kind === 'E' && // only return overrides
        !e.path?.includes('node') && // stop traversing once the object graph hits the node
        !e.path?.includes('bind') // stop traversing once the object graph hits internal functions
    )) : [];
}
/**
 * Converts the path object from the deep-diff module to a user-readable, bracket notation format.
 * @param {string | string[]} path either a string value or an array of strings.
 * @return {string} the formatted override path.
 */
function formatOverridePath(path) {
    return (path !== undefined && path.length > 1) ? path.toString()
        .replace(/,/g, '][')
        .replace(/\]{1}/, '')
        .replace(/$/, ']') : path;
}
/**
 * Check the readability of an input value and, in the context of the override warning service, return true if it
 * meets the established criteria. This function is used to determine whether more-detailed log output can be given.
 * @param {any} value input to be evaluated against the given criteria.
 * @return {boolean} true if the value meets the given criteria.
 * @return {boolean} false if the value does not meet the given criteria.
 */
function checkReadability(value) {
    return (typeof (value) === 'string' && // strings only
        !value.includes('${Token[') && // no circular refs
        value !== '' // no empty strings
    );
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcnJpZGUtd2FybmluZy1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3ZlcnJpZGUtd2FybmluZy1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7R0FXRzs7O0FBRUg7OztHQUdHO0FBRUgsc0NBQXNDO0FBQ3RDLG1DQUF1QztBQUV2Qzs7Ozs7O0dBTUc7QUFDSCxTQUFnQixzQkFBc0IsQ0FBQyxZQUFvQixFQUFFLFNBQWlCO0lBQzVFLGtEQUFrRDtJQUNsRCxNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3pELG1DQUFtQztJQUNuQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDM0UsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0Qyw0Q0FBNEM7UUFDNUMsTUFBTSxpQkFBaUIsR0FBRyxDQUN4QixnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQ3ZCLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDeEIsQ0FBQztRQUNGLGtDQUFrQztRQUNsQyxNQUFNLElBQUksR0FBRyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEMsU0FBUztRQUNULE1BQU0sT0FBTyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxHQUFHLHFCQUFxQixDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNuRyxvQkFBWSxDQUFDLG1EQUFtRCxJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQztLQUNwRjtBQUNILENBQUM7QUFqQkQsd0RBaUJDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsVUFBVSxDQUFDLEtBQVksRUFBRSxJQUFZO0lBQzVDLE1BQU0sVUFBVSxHQUFHLENBQUMsY0FBYyxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXpHLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDakMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxhQUFhLENBQUMsWUFBb0IsRUFBRSxTQUFpQjtJQUM1RCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDaEUscUJBQXFCO0lBQ3JCLE9BQU8sQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQ2hELENBQUMsQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJLHdCQUF3QjtRQUMxQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLHNEQUFzRDtRQUNuRixDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLGdFQUFnRTtLQUMzRixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUNWLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxJQUF1QjtJQUNqRCxPQUFPLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1NBQzdELE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO1NBQ25CLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO1NBQ3BCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM5QixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFVO0lBQ2xDLE9BQU8sQ0FDTCxPQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxJQUFJLGVBQWU7UUFDN0MsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLG1CQUFtQjtRQUNsRCxLQUFLLEtBQUssRUFBRSxDQUFDLG1CQUFtQjtLQUNqQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiAgd2l0aCB0aGUgTGljZW5zZS4gQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBvciBpbiB0aGUgJ2xpY2Vuc2UnIGZpbGUgYWNjb21wYW55aW5nIHRoaXMgZmlsZS4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFU1xuICogIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG4gKiAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qXG4gKiAgVGhlIGZ1bmN0aW9ucyBmb3VuZCBoZXJlIGluIHRoZSBjb3JlIGxpYnJhcnkgYXJlIGZvciBpbnRlcm5hbCB1c2UgYW5kIGNhbiBiZSBjaGFuZ2VkXG4gKiAgb3IgcmVtb3ZlZCBvdXRzaWRlIG9mIGEgbWFqb3IgcmVsZWFzZS4gV2UgcmVjb21tZW5kIGFnYWluc3QgY2FsbGluZyB0aGVtIGRpcmVjdGx5IGZyb20gY2xpZW50IGNvZGUuXG4gKi9cblxuaW1wb3J0ICogYXMgZGVlcGRpZmYgZnJvbSAnZGVlcC1kaWZmJztcbmltcG9ydCB7IHByaW50V2FybmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBpbnRlcm5hbCBUaGlzIGlzIGFuIGludGVybmFsIGNvcmUgZnVuY3Rpb24gYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5IGJ5IFNvbHV0aW9ucyBDb25zdHJ1Y3RzIGNsaWVudHMuXG4gKlxuICogRW1pdHMgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIHdoZW4gYSBwcmVzY3JpcHRpdmUgZGVmYXVsdCB2YWx1ZSBpcyBvdmVycmlkZGVuIGJ5IHRoZSB1c2VyLlxuICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRQcm9wcyB0aGUgcHJlc2NyaXB0aXZlIGRlZmF1bHRzIGZvciB0aGUgcGF0dGVybi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB1c2VyUHJvcHMgdGhlIHByb3BlcnRpZXMgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIHRvIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIGRlZmF1bHRQcm9wcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYWdPdmVycmlkZGVuRGVmYXVsdHMoZGVmYXVsdFByb3BzOiBvYmplY3QsIHVzZXJQcm9wczogb2JqZWN0KSB7XG4gIC8vIENvbXBhcmUgdGhlIHByb3BlcnRpZXMgYW5kIHJldHVybiBhbnkgb3ZlcnJpZGVzXG4gIGNvbnN0IG92ZXJyaWRlcyA9IGZpbmRPdmVycmlkZXMoZGVmYXVsdFByb3BzLCB1c2VyUHJvcHMpO1xuICAvLyBFbWl0IGEgd2FybmluZyBmb3IgZWFjaCBvdmVycmlkZVxuICBmb3IgKGxldCBpID0gMDsgaSA8ICgob3ZlcnJpZGVzICE9PSB1bmRlZmluZWQpID8gb3ZlcnJpZGVzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmFzc2lnbihvdmVycmlkZXNbaV0pO1xuICAgIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSBsb2dnaW5nIGdyYW51bGFyaXR5XG4gICAgY29uc3QgdmFsdWVzQXJlUmVhZGFibGUgPSAoXG4gICAgICBjaGVja1JlYWRhYmlsaXR5KGUubGhzKSAmJlxuICAgICAgY2hlY2tSZWFkYWJpbGl0eShlLnJocylcbiAgICApO1xuICAgIC8vIEZvcm1hdCB0aGUgcGF0aCBmb3IgcmVhZGFiaWxpdHlcbiAgICBjb25zdCBwYXRoID0gZm9ybWF0T3ZlcnJpZGVQYXRoKGUucGF0aCk7XG4gICAgLy8gT3V0cHV0XG4gICAgY29uc3QgZGV0YWlscyA9ICh2YWx1ZXNBcmVSZWFkYWJsZSkgPyBgIERlZmF1bHQgdmFsdWU6ICcke2UubGhzfScuIFlvdSBwcm92aWRlZDogJyR7ZS5yaHN9Jy5gIDogJyc7XG4gICAgcHJpbnRXYXJuaW5nKGBBbiBvdmVycmlkZSBoYXMgYmVlbiBwcm92aWRlZCBmb3IgdGhlIHByb3BlcnR5OiAke3BhdGh9LmAgKyBkZXRhaWxzKTtcbiAgfVxufVxuXG4vKiogVGhlIHByZWZpbHRlciBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFueSBmaWx0ZXJlZCBwYXRoL2tleSB0aGF0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIHRoZSBkaWZmIGNoZWNrLlxuICogQW55IENvbnN0cnVjdCBQcm9wcyB1c2luZyBjZGsuRHVyYXRpb24gdHlwZSBpcyBub3QgcHJvcGVybHkgaGFuZGxlZCBieVxuICogJ2RlZXAtZGlmZicgbGlicmFyeSwgd2hlbmV2ZXIgaXQgZW5jb3VudGVycyBhIER1cmF0aW9uIG9iamVjdCwgaXQgdGhyb3dzIHRoZSBleGNlcHRpb25cbiAqICdBcmd1bWVudCB0byBJbnRyaW5zaWMgbXVzdCBiZSBhIHBsYWluIHZhbHVlIG9iamVjdCcsIHNvIHN1Y2ggcHJvcHMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRpZmYgY2hlY2suXG4gKi9cbmZ1bmN0aW9uIF9wcmVmaWx0ZXIoX3BhdGg6IGFueVtdLCBfa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcHJlZmlsdGVycyA9IFsnbWF4UmVjb3JkQWdlJywgJ2V4cGlyYXRpb24nLCAndHJhbnNpdGlvbkFmdGVyJywgJ2Rlc3RpbmF0aW9uJywgJ3RpbWVvdXQnLCAncGVyaW9kJ107XG5cbiAgaWYgKHByZWZpbHRlcnMuaW5kZXhPZihfa2V5KSA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGlmZiBjaGVjayBvZiB0aGUgdXNlclByb3BzIGFnYWluc3QgdGhlIGRlZmF1bHRQcm9wcyB0byBkZXRlY3Qgb3ZlcnJpZGRlbiBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRQcm9wcyB0aGUgcHJlc2NyaXB0aXZlIGRlZmF1bHRzIGZvciB0aGUgcGF0dGVybi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB1c2VyUHJvcHMgdGhlIHByb3BlcnRpZXMgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIHRvIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIGRlZmF1bHRQcm9wcy5cbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBjb250YWluaW5nIHRoZSBvdmVycmlkZGVuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZmluZE92ZXJyaWRlcyhkZWZhdWx0UHJvcHM6IG9iamVjdCwgdXNlclByb3BzOiBvYmplY3QpIHtcbiAgY29uc3QgZGlmZiA9IGRlZXBkaWZmLmRpZmYoZGVmYXVsdFByb3BzLCB1c2VyUHJvcHMsIF9wcmVmaWx0ZXIpO1xuICAvLyBGaWx0ZXIgdGhlIHJlc3VsdHNcbiAgcmV0dXJuIChkaWZmICE9PSB1bmRlZmluZWQpID8gZGlmZj8uZmlsdGVyKChlKSA9PiAoXG4gICAgZS5raW5kID09PSAnRScgJiYgLy8gb25seSByZXR1cm4gb3ZlcnJpZGVzXG4gICAgIWUucGF0aD8uaW5jbHVkZXMoJ25vZGUnKSAmJiAvLyBzdG9wIHRyYXZlcnNpbmcgb25jZSB0aGUgb2JqZWN0IGdyYXBoIGhpdHMgdGhlIG5vZGVcbiAgICAhZS5wYXRoPy5pbmNsdWRlcygnYmluZCcpIC8vIHN0b3AgdHJhdmVyc2luZyBvbmNlIHRoZSBvYmplY3QgZ3JhcGggaGl0cyBpbnRlcm5hbCBmdW5jdGlvbnNcbiAgKSkgOiBbXTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcGF0aCBvYmplY3QgZnJvbSB0aGUgZGVlcC1kaWZmIG1vZHVsZSB0byBhIHVzZXItcmVhZGFibGUsIGJyYWNrZXQgbm90YXRpb24gZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gcGF0aCBlaXRoZXIgYSBzdHJpbmcgdmFsdWUgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGZvcm1hdHRlZCBvdmVycmlkZSBwYXRoLlxuICovXG5mdW5jdGlvbiBmb3JtYXRPdmVycmlkZVBhdGgocGF0aDogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgcmV0dXJuIChwYXRoICE9PSB1bmRlZmluZWQgJiYgcGF0aC5sZW5ndGggPiAxKSA/IHBhdGgudG9TdHJpbmcoKVxuICAgIC5yZXBsYWNlKC8sL2csICddWycpXG4gICAgLnJlcGxhY2UoL1xcXXsxfS8sICcnKVxuICAgIC5yZXBsYWNlKC8kLywgJ10nKSA6IHBhdGg7XG59XG5cbi8qKlxuICogQ2hlY2sgdGhlIHJlYWRhYmlsaXR5IG9mIGFuIGlucHV0IHZhbHVlIGFuZCwgaW4gdGhlIGNvbnRleHQgb2YgdGhlIG92ZXJyaWRlIHdhcm5pbmcgc2VydmljZSwgcmV0dXJuIHRydWUgaWYgaXRcbiAqIG1lZXRzIHRoZSBlc3RhYmxpc2hlZCBjcml0ZXJpYS4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG1vcmUtZGV0YWlsZWQgbG9nIG91dHB1dCBjYW4gYmUgZ2l2ZW4uXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgaW5wdXQgdG8gYmUgZXZhbHVhdGVkIGFnYWluc3QgdGhlIGdpdmVuIGNyaXRlcmlhLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdmFsdWUgbWVldHMgdGhlIGdpdmVuIGNyaXRlcmlhLlxuICogQHJldHVybiB7Ym9vbGVhbn0gZmFsc2UgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1lZXQgdGhlIGdpdmVuIGNyaXRlcmlhLlxuICovXG5mdW5jdGlvbiBjaGVja1JlYWRhYmlsaXR5KHZhbHVlOiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJyAmJiAvLyBzdHJpbmdzIG9ubHlcbiAgICAhdmFsdWUuaW5jbHVkZXMoJyR7VG9rZW5bJykgJiYgLy8gbm8gY2lyY3VsYXIgcmVmc1xuICAgIHZhbHVlICE9PSAnJyAvLyBubyBlbXB0eSBzdHJpbmdzXG4gICk7XG59Il19