"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskDefinitionPlacementConstraintType = exports.PidMode = exports.NetworkMode = exports.IpcMode = exports.UlimitName = exports.ResourceType = exports.TransportProtocol = exports.ApplicationProtocol = exports.DeviceCgroupPermission = exports.FirelensConfigurationType = exports.EnvironmentFileType = exports.ContainerCondition = exports.Compatibility = exports.ClusterContainsTasksException = exports.ClusterContainsServicesException = exports.ClusterContainsContainerInstancesException = exports.TargetNotFoundException = exports.TargetType = exports.SettingName = exports.ServiceNotFoundException = exports.ServiceNotActiveException = exports.UnsupportedFeatureException = exports.PlatformUnknownException = exports.PlatformTaskDefinitionIncompatibilityException = exports.NamespaceNotFoundException = exports.StabilityStatus = exports.ScaleUnit = exports.DeploymentRolloutState = exports.LogDriver = exports.SchedulingStrategy = exports.PropagateTags = exports.PlacementStrategyType = exports.PlacementConstraintType = exports.AssignPublicIp = exports.LaunchType = exports.DeploymentControllerType = exports.ClusterNotFoundException = exports.ClusterSettingName = exports.ExecuteCommandLogging = exports.UpdateInProgressException = exports.ServerException = exports.LimitExceededException = exports.InvalidParameterException = exports.CapacityProviderUpdateStatus = exports.CapacityProviderStatus = exports.ManagedTerminationProtection = exports.ManagedScalingStatus = exports.ClientException = exports.AgentUpdateStatus = exports.AccessDeniedException = void 0;
exports.ExecuteCommandResponseFilterSensitiveLog = exports.SessionFilterSensitiveLog = exports.NoUpdateAvailableException = exports.MissingVersionException = exports.BlockedException = exports.PlatformDeviceType = exports.ResourceInUseException = exports.AttributeLimitExceededException = exports.DesiredStatus = exports.SortOrder = exports.TaskDefinitionFamilyStatus = exports.ContainerInstanceStatus = exports.ResourceNotFoundException = exports.TargetNotConnectedException = exports.TaskSetField = exports.TaskStopCode = exports.ManagedAgentName = exports.HealthStatus = exports.Connectivity = exports.TaskField = exports.TaskDefinitionField = exports.ServiceField = exports.ContainerInstanceField = exports.ClusterField = exports.CapacityProviderField = exports.InstanceHealthCheckType = exports.InstanceHealthCheckState = exports.TaskSetNotFoundException = exports.EFSTransitEncryption = exports.EFSAuthorizationConfigIAM = exports.Scope = exports.TaskDefinitionStatus = exports.OSFamily = exports.CPUArchitecture = exports.ProxyConfigurationType = void 0;
const smithy_client_1 = require("@aws-sdk/smithy-client");
const ECSServiceException_1 = require("./ECSServiceException");
class AccessDeniedException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
    }
}
exports.AccessDeniedException = AccessDeniedException;
exports.AgentUpdateStatus = {
    FAILED: "FAILED",
    PENDING: "PENDING",
    STAGED: "STAGED",
    STAGING: "STAGING",
    UPDATED: "UPDATED",
    UPDATING: "UPDATING",
};
class ClientException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClientException.prototype);
    }
}
exports.ClientException = ClientException;
exports.ManagedScalingStatus = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
exports.ManagedTerminationProtection = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
exports.CapacityProviderStatus = {
    ACTIVE: "ACTIVE",
    INACTIVE: "INACTIVE",
};
exports.CapacityProviderUpdateStatus = {
    DELETE_COMPLETE: "DELETE_COMPLETE",
    DELETE_FAILED: "DELETE_FAILED",
    DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS",
    UPDATE_COMPLETE: "UPDATE_COMPLETE",
    UPDATE_FAILED: "UPDATE_FAILED",
    UPDATE_IN_PROGRESS: "UPDATE_IN_PROGRESS",
};
class InvalidParameterException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "InvalidParameterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidParameterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidParameterException.prototype);
    }
}
exports.InvalidParameterException = InvalidParameterException;
class LimitExceededException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
exports.LimitExceededException = LimitExceededException;
class ServerException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "ServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, ServerException.prototype);
    }
}
exports.ServerException = ServerException;
class UpdateInProgressException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "UpdateInProgressException",
            $fault: "client",
            ...opts,
        });
        this.name = "UpdateInProgressException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UpdateInProgressException.prototype);
    }
}
exports.UpdateInProgressException = UpdateInProgressException;
exports.ExecuteCommandLogging = {
    DEFAULT: "DEFAULT",
    NONE: "NONE",
    OVERRIDE: "OVERRIDE",
};
exports.ClusterSettingName = {
    CONTAINER_INSIGHTS: "containerInsights",
};
class ClusterNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterNotFoundException.prototype);
    }
}
exports.ClusterNotFoundException = ClusterNotFoundException;
exports.DeploymentControllerType = {
    CODE_DEPLOY: "CODE_DEPLOY",
    ECS: "ECS",
    EXTERNAL: "EXTERNAL",
};
exports.LaunchType = {
    EC2: "EC2",
    EXTERNAL: "EXTERNAL",
    FARGATE: "FARGATE",
};
exports.AssignPublicIp = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
exports.PlacementConstraintType = {
    DISTINCT_INSTANCE: "distinctInstance",
    MEMBER_OF: "memberOf",
};
exports.PlacementStrategyType = {
    BINPACK: "binpack",
    RANDOM: "random",
    SPREAD: "spread",
};
exports.PropagateTags = {
    NONE: "NONE",
    SERVICE: "SERVICE",
    TASK_DEFINITION: "TASK_DEFINITION",
};
exports.SchedulingStrategy = {
    DAEMON: "DAEMON",
    REPLICA: "REPLICA",
};
exports.LogDriver = {
    AWSFIRELENS: "awsfirelens",
    AWSLOGS: "awslogs",
    FLUENTD: "fluentd",
    GELF: "gelf",
    JOURNALD: "journald",
    JSON_FILE: "json-file",
    SPLUNK: "splunk",
    SYSLOG: "syslog",
};
exports.DeploymentRolloutState = {
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    IN_PROGRESS: "IN_PROGRESS",
};
exports.ScaleUnit = {
    PERCENT: "PERCENT",
};
exports.StabilityStatus = {
    STABILIZING: "STABILIZING",
    STEADY_STATE: "STEADY_STATE",
};
class NamespaceNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "NamespaceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "NamespaceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NamespaceNotFoundException.prototype);
    }
}
exports.NamespaceNotFoundException = NamespaceNotFoundException;
class PlatformTaskDefinitionIncompatibilityException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "PlatformTaskDefinitionIncompatibilityException",
            $fault: "client",
            ...opts,
        });
        this.name = "PlatformTaskDefinitionIncompatibilityException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PlatformTaskDefinitionIncompatibilityException.prototype);
    }
}
exports.PlatformTaskDefinitionIncompatibilityException = PlatformTaskDefinitionIncompatibilityException;
class PlatformUnknownException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "PlatformUnknownException",
            $fault: "client",
            ...opts,
        });
        this.name = "PlatformUnknownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PlatformUnknownException.prototype);
    }
}
exports.PlatformUnknownException = PlatformUnknownException;
class UnsupportedFeatureException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedFeatureException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedFeatureException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedFeatureException.prototype);
    }
}
exports.UnsupportedFeatureException = UnsupportedFeatureException;
class ServiceNotActiveException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ServiceNotActiveException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceNotActiveException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceNotActiveException.prototype);
    }
}
exports.ServiceNotActiveException = ServiceNotActiveException;
class ServiceNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ServiceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceNotFoundException.prototype);
    }
}
exports.ServiceNotFoundException = ServiceNotFoundException;
exports.SettingName = {
    AWSVPC_TRUNKING: "awsvpcTrunking",
    CONTAINER_INSIGHTS: "containerInsights",
    CONTAINER_INSTANCE_LONG_ARN_FORMAT: "containerInstanceLongArnFormat",
    SERVICE_LONG_ARN_FORMAT: "serviceLongArnFormat",
    TASK_LONG_ARN_FORMAT: "taskLongArnFormat",
};
exports.TargetType = {
    CONTAINER_INSTANCE: "container-instance",
};
class TargetNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "TargetNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "TargetNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TargetNotFoundException.prototype);
    }
}
exports.TargetNotFoundException = TargetNotFoundException;
class ClusterContainsContainerInstancesException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterContainsContainerInstancesException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterContainsContainerInstancesException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterContainsContainerInstancesException.prototype);
    }
}
exports.ClusterContainsContainerInstancesException = ClusterContainsContainerInstancesException;
class ClusterContainsServicesException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterContainsServicesException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterContainsServicesException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterContainsServicesException.prototype);
    }
}
exports.ClusterContainsServicesException = ClusterContainsServicesException;
class ClusterContainsTasksException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterContainsTasksException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterContainsTasksException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterContainsTasksException.prototype);
    }
}
exports.ClusterContainsTasksException = ClusterContainsTasksException;
exports.Compatibility = {
    EC2: "EC2",
    EXTERNAL: "EXTERNAL",
    FARGATE: "FARGATE",
};
exports.ContainerCondition = {
    COMPLETE: "COMPLETE",
    HEALTHY: "HEALTHY",
    START: "START",
    SUCCESS: "SUCCESS",
};
exports.EnvironmentFileType = {
    S3: "s3",
};
exports.FirelensConfigurationType = {
    FLUENTBIT: "fluentbit",
    FLUENTD: "fluentd",
};
exports.DeviceCgroupPermission = {
    MKNOD: "mknod",
    READ: "read",
    WRITE: "write",
};
exports.ApplicationProtocol = {
    GRPC: "grpc",
    HTTP: "http",
    HTTP2: "http2",
};
exports.TransportProtocol = {
    TCP: "tcp",
    UDP: "udp",
};
exports.ResourceType = {
    GPU: "GPU",
    INFERENCE_ACCELERATOR: "InferenceAccelerator",
};
exports.UlimitName = {
    CORE: "core",
    CPU: "cpu",
    DATA: "data",
    FSIZE: "fsize",
    LOCKS: "locks",
    MEMLOCK: "memlock",
    MSGQUEUE: "msgqueue",
    NICE: "nice",
    NOFILE: "nofile",
    NPROC: "nproc",
    RSS: "rss",
    RTPRIO: "rtprio",
    RTTIME: "rttime",
    SIGPENDING: "sigpending",
    STACK: "stack",
};
exports.IpcMode = {
    HOST: "host",
    NONE: "none",
    TASK: "task",
};
exports.NetworkMode = {
    AWSVPC: "awsvpc",
    BRIDGE: "bridge",
    HOST: "host",
    NONE: "none",
};
exports.PidMode = {
    HOST: "host",
    TASK: "task",
};
exports.TaskDefinitionPlacementConstraintType = {
    MEMBER_OF: "memberOf",
};
exports.ProxyConfigurationType = {
    APPMESH: "APPMESH",
};
exports.CPUArchitecture = {
    ARM64: "ARM64",
    X86_64: "X86_64",
};
exports.OSFamily = {
    LINUX: "LINUX",
    WINDOWS_SERVER_2004_CORE: "WINDOWS_SERVER_2004_CORE",
    WINDOWS_SERVER_2016_FULL: "WINDOWS_SERVER_2016_FULL",
    WINDOWS_SERVER_2019_CORE: "WINDOWS_SERVER_2019_CORE",
    WINDOWS_SERVER_2019_FULL: "WINDOWS_SERVER_2019_FULL",
    WINDOWS_SERVER_2022_CORE: "WINDOWS_SERVER_2022_CORE",
    WINDOWS_SERVER_2022_FULL: "WINDOWS_SERVER_2022_FULL",
    WINDOWS_SERVER_20H2_CORE: "WINDOWS_SERVER_20H2_CORE",
};
exports.TaskDefinitionStatus = {
    ACTIVE: "ACTIVE",
    DELETE_IN_PROGRESS: "DELETE_IN_PROGRESS",
    INACTIVE: "INACTIVE",
};
exports.Scope = {
    SHARED: "shared",
    TASK: "task",
};
exports.EFSAuthorizationConfigIAM = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
exports.EFSTransitEncryption = {
    DISABLED: "DISABLED",
    ENABLED: "ENABLED",
};
class TaskSetNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "TaskSetNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "TaskSetNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TaskSetNotFoundException.prototype);
    }
}
exports.TaskSetNotFoundException = TaskSetNotFoundException;
exports.InstanceHealthCheckState = {
    IMPAIRED: "IMPAIRED",
    INITIALIZING: "INITIALIZING",
    INSUFFICIENT_DATA: "INSUFFICIENT_DATA",
    OK: "OK",
};
exports.InstanceHealthCheckType = {
    CONTAINER_RUNTIME: "CONTAINER_RUNTIME",
};
exports.CapacityProviderField = {
    TAGS: "TAGS",
};
exports.ClusterField = {
    ATTACHMENTS: "ATTACHMENTS",
    CONFIGURATIONS: "CONFIGURATIONS",
    SETTINGS: "SETTINGS",
    STATISTICS: "STATISTICS",
    TAGS: "TAGS",
};
exports.ContainerInstanceField = {
    CONTAINER_INSTANCE_HEALTH: "CONTAINER_INSTANCE_HEALTH",
    TAGS: "TAGS",
};
exports.ServiceField = {
    TAGS: "TAGS",
};
exports.TaskDefinitionField = {
    TAGS: "TAGS",
};
exports.TaskField = {
    TAGS: "TAGS",
};
exports.Connectivity = {
    CONNECTED: "CONNECTED",
    DISCONNECTED: "DISCONNECTED",
};
exports.HealthStatus = {
    HEALTHY: "HEALTHY",
    UNHEALTHY: "UNHEALTHY",
    UNKNOWN: "UNKNOWN",
};
exports.ManagedAgentName = {
    ExecuteCommandAgent: "ExecuteCommandAgent",
};
exports.TaskStopCode = {
    ESSENTIAL_CONTAINER_EXITED: "EssentialContainerExited",
    SERVICE_SCHEDULER_INITIATED: "ServiceSchedulerInitiated",
    SPOT_INTERRUPTION: "SpotInterruption",
    TASK_FAILED_TO_START: "TaskFailedToStart",
    TERMINATION_NOTICE: "TerminationNotice",
    USER_INITIATED: "UserInitiated",
};
exports.TaskSetField = {
    TAGS: "TAGS",
};
class TargetNotConnectedException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "TargetNotConnectedException",
            $fault: "client",
            ...opts,
        });
        this.name = "TargetNotConnectedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TargetNotConnectedException.prototype);
    }
}
exports.TargetNotConnectedException = TargetNotConnectedException;
class ResourceNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
exports.ContainerInstanceStatus = {
    ACTIVE: "ACTIVE",
    DEREGISTERING: "DEREGISTERING",
    DRAINING: "DRAINING",
    REGISTERING: "REGISTERING",
    REGISTRATION_FAILED: "REGISTRATION_FAILED",
};
exports.TaskDefinitionFamilyStatus = {
    ACTIVE: "ACTIVE",
    ALL: "ALL",
    INACTIVE: "INACTIVE",
};
exports.SortOrder = {
    ASC: "ASC",
    DESC: "DESC",
};
exports.DesiredStatus = {
    PENDING: "PENDING",
    RUNNING: "RUNNING",
    STOPPED: "STOPPED",
};
class AttributeLimitExceededException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "AttributeLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "AttributeLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AttributeLimitExceededException.prototype);
    }
}
exports.AttributeLimitExceededException = AttributeLimitExceededException;
class ResourceInUseException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ResourceInUseException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceInUseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceInUseException.prototype);
    }
}
exports.ResourceInUseException = ResourceInUseException;
exports.PlatformDeviceType = {
    GPU: "GPU",
};
class BlockedException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "BlockedException",
            $fault: "client",
            ...opts,
        });
        this.name = "BlockedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BlockedException.prototype);
    }
}
exports.BlockedException = BlockedException;
class MissingVersionException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "MissingVersionException",
            $fault: "client",
            ...opts,
        });
        this.name = "MissingVersionException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MissingVersionException.prototype);
    }
}
exports.MissingVersionException = MissingVersionException;
class NoUpdateAvailableException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "NoUpdateAvailableException",
            $fault: "client",
            ...opts,
        });
        this.name = "NoUpdateAvailableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoUpdateAvailableException.prototype);
    }
}
exports.NoUpdateAvailableException = NoUpdateAvailableException;
const SessionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.tokenValue && { tokenValue: smithy_client_1.SENSITIVE_STRING }),
});
exports.SessionFilterSensitiveLog = SessionFilterSensitiveLog;
const ExecuteCommandResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.session && { session: (0, exports.SessionFilterSensitiveLog)(obj.session) }),
});
exports.ExecuteCommandResponseFilterSensitiveLog = ExecuteCommandResponseFilterSensitiveLog;
