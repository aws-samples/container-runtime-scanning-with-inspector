"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = exports.JobErrorResourceTypes = exports.JobErrorLimitName = exports.Type = exports.TableTagPolicyLFPermission = exports.DatabaseLFTagPolicyPermission = exports.ServiceLimitExceededException = exports.LimitName = exports.Origin = exports.Code = exports.ValidationException = exports.ExceptionCause = exports.ThrottlingException = exports.ResourceNotFoundException = exports.InternalServerException = exports.ConflictException = exports.ResourceType = exports.AssetType = exports.LFPermission = exports.LakeFormationDataPermissionType = exports.LFResourceType = exports.ProtocolType = exports.ServerSideEncryptionTypes = exports.AccessDeniedException = void 0;
const DataExchangeServiceException_1 = require("./DataExchangeServiceException");
class AccessDeniedException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.Message = opts.Message;
    }
}
exports.AccessDeniedException = AccessDeniedException;
exports.ServerSideEncryptionTypes = {
    AES256: "AES256",
    aws_kms: "aws:kms",
};
exports.ProtocolType = {
    REST: "REST",
};
exports.LFResourceType = {
    DATABASE: "DATABASE",
    TABLE: "TABLE",
};
exports.LakeFormationDataPermissionType = {
    LFTagPolicy: "LFTagPolicy",
};
exports.LFPermission = {
    DESCRIBE: "DESCRIBE",
    SELECT: "SELECT",
};
exports.AssetType = {
    API_GATEWAY_API: "API_GATEWAY_API",
    LAKE_FORMATION_DATA_PERMISSION: "LAKE_FORMATION_DATA_PERMISSION",
    REDSHIFT_DATA_SHARE: "REDSHIFT_DATA_SHARE",
    S3_DATA_ACCESS: "S3_DATA_ACCESS",
    S3_SNAPSHOT: "S3_SNAPSHOT",
};
exports.ResourceType = {
    ASSET: "ASSET",
    DATA_SET: "DATA_SET",
    EVENT_ACTION: "EVENT_ACTION",
    JOB: "JOB",
    REVISION: "REVISION",
};
class ConflictException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "ConflictException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConflictException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConflictException.prototype);
        this.Message = opts.Message;
        this.ResourceId = opts.ResourceId;
        this.ResourceType = opts.ResourceType;
    }
}
exports.ConflictException = ConflictException;
class InternalServerException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.Message = opts.Message;
    }
}
exports.InternalServerException = InternalServerException;
class ResourceNotFoundException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        this.Message = opts.Message;
        this.ResourceId = opts.ResourceId;
        this.ResourceType = opts.ResourceType;
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class ThrottlingException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "ThrottlingException",
            $fault: "client",
            ...opts,
        });
        this.name = "ThrottlingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ThrottlingException.prototype);
        this.Message = opts.Message;
    }
}
exports.ThrottlingException = ThrottlingException;
exports.ExceptionCause = {
    InsufficientS3BucketPolicy: "InsufficientS3BucketPolicy",
    S3AccessDenied: "S3AccessDenied",
};
class ValidationException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "ValidationException",
            $fault: "client",
            ...opts,
        });
        this.name = "ValidationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ValidationException.prototype);
        this.Message = opts.Message;
        this.ExceptionCause = opts.ExceptionCause;
    }
}
exports.ValidationException = ValidationException;
exports.Code = {
    ACCESS_DENIED_EXCEPTION: "ACCESS_DENIED_EXCEPTION",
    INTERNAL_SERVER_EXCEPTION: "INTERNAL_SERVER_EXCEPTION",
    MALWARE_DETECTED: "MALWARE_DETECTED",
    MALWARE_SCAN_ENCRYPTED_FILE: "MALWARE_SCAN_ENCRYPTED_FILE",
    RESOURCE_NOT_FOUND_EXCEPTION: "RESOURCE_NOT_FOUND_EXCEPTION",
    SERVICE_QUOTA_EXCEEDED_EXCEPTION: "SERVICE_QUOTA_EXCEEDED_EXCEPTION",
    VALIDATION_EXCEPTION: "VALIDATION_EXCEPTION",
};
exports.Origin = {
    ENTITLED: "ENTITLED",
    OWNED: "OWNED",
};
exports.LimitName = {
    AWS_Lake_Formation_data_permission_assets_per_revision: "AWS Lake Formation data permission assets per revision",
    Amazon_API_Gateway_API_assets_per_revision: "Amazon API Gateway API assets per revision",
    Amazon_Redshift_datashare_assets_per_import_job_from_Redshift: "Amazon Redshift datashare assets per import job from Redshift",
    Amazon_Redshift_datashare_assets_per_revision: "Amazon Redshift datashare assets per revision",
    Amazon_S3_data_access_assets_per_revision: "Amazon S3 data access assets per revision",
    Asset_per_export_job_from_Amazon_S3: "Asset per export job from Amazon S3",
    Asset_size_in_GB: "Asset size in GB",
    Assets_per_import_job_from_Amazon_S3: "Assets per import job from Amazon S3",
    Assets_per_revision: "Assets per revision",
    Auto_export_event_actions_per_data_set: "Auto export event actions per data set",
    Concurrent_in_progress_jobs_to_create_Amazon_S3_data_access_assets_from_S3_buckets: "Concurrent in progress jobs to create Amazon S3 data access assets from S3 buckets",
    Concurrent_in_progress_jobs_to_export_assets_to_Amazon_S3: "Concurrent in progress jobs to export assets to Amazon S3",
    Concurrent_in_progress_jobs_to_export_assets_to_a_signed_URL: "Concurrent in progress jobs to export assets to a signed URL",
    Concurrent_in_progress_jobs_to_export_revisions_to_Amazon_S3: "Concurrent in progress jobs to export revisions to Amazon S3",
    Concurrent_in_progress_jobs_to_import_assets_from_Amazon_Redshift_datashares: "Concurrent in progress jobs to import assets from Amazon Redshift datashares",
    Concurrent_in_progress_jobs_to_import_assets_from_Amazon_S3: "Concurrent in progress jobs to import assets from Amazon S3",
    Concurrent_in_progress_jobs_to_import_assets_from_a_signed_URL: "Concurrent in progress jobs to import assets from a signed URL",
    Concurrent_in_progress_jobs_to_import_assets_from_an_API_Gateway_API: "Concurrent in progress jobs to import assets from an API Gateway API",
    Concurrent_in_progress_jobs_to_import_assets_from_an_AWS_Lake_Formation_tag_policy: "Concurrent in progress jobs to import assets from an AWS Lake Formation tag policy",
    Data_sets_per_account: "Data sets per account",
    Data_sets_per_product: "Data sets per product",
    Event_actions_per_account: "Event actions per account",
    Products_per_account: "Products per account",
    Revisions_per_AWS_Lake_Formation_data_permission_data_set: "Revisions per AWS Lake Formation data permission data set",
    Revisions_per_Amazon_API_Gateway_API_data_set: "Revisions per Amazon API Gateway API data set",
    Revisions_per_Amazon_Redshift_datashare_data_set: "Revisions per Amazon Redshift datashare data set",
    Revisions_per_Amazon_S3_data_access_data_set: "Revisions per Amazon S3 data access data set",
    Revisions_per_data_set: "Revisions per data set",
};
class ServiceLimitExceededException extends DataExchangeServiceException_1.DataExchangeServiceException {
    constructor(opts) {
        super({
            name: "ServiceLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceLimitExceededException.prototype);
        this.LimitName = opts.LimitName;
        this.LimitValue = opts.LimitValue;
        this.Message = opts.Message;
    }
}
exports.ServiceLimitExceededException = ServiceLimitExceededException;
exports.DatabaseLFTagPolicyPermission = {
    DESCRIBE: "DESCRIBE",
};
exports.TableTagPolicyLFPermission = {
    DESCRIBE: "DESCRIBE",
    SELECT: "SELECT",
};
exports.Type = {
    CREATE_S3_DATA_ACCESS_FROM_S3_BUCKET: "CREATE_S3_DATA_ACCESS_FROM_S3_BUCKET",
    EXPORT_ASSETS_TO_S3: "EXPORT_ASSETS_TO_S3",
    EXPORT_ASSET_TO_SIGNED_URL: "EXPORT_ASSET_TO_SIGNED_URL",
    EXPORT_REVISIONS_TO_S3: "EXPORT_REVISIONS_TO_S3",
    IMPORT_ASSETS_FROM_LAKE_FORMATION_TAG_POLICY: "IMPORT_ASSETS_FROM_LAKE_FORMATION_TAG_POLICY",
    IMPORT_ASSETS_FROM_REDSHIFT_DATA_SHARES: "IMPORT_ASSETS_FROM_REDSHIFT_DATA_SHARES",
    IMPORT_ASSETS_FROM_S3: "IMPORT_ASSETS_FROM_S3",
    IMPORT_ASSET_FROM_API_GATEWAY_API: "IMPORT_ASSET_FROM_API_GATEWAY_API",
    IMPORT_ASSET_FROM_SIGNED_URL: "IMPORT_ASSET_FROM_SIGNED_URL",
};
exports.JobErrorLimitName = {
    AWS_Lake_Formation_data_permission_assets_per_revision: "AWS Lake Formation data permission assets per revision",
    Amazon_Redshift_datashare_assets_per_revision: "Amazon Redshift datashare assets per revision",
    Amazon_S3_data_access_assets_per_revision: "Amazon S3 data access assets per revision",
    Asset_size_in_GB: "Asset size in GB",
    Assets_per_revision: "Assets per revision",
};
exports.JobErrorResourceTypes = {
    ASSET: "ASSET",
    DATA_SET: "DATA_SET",
    REVISION: "REVISION",
};
exports.State = {
    CANCELLED: "CANCELLED",
    COMPLETED: "COMPLETED",
    ERROR: "ERROR",
    IN_PROGRESS: "IN_PROGRESS",
    TIMED_OUT: "TIMED_OUT",
    WAITING: "WAITING",
};
