import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
import { EKSServiceException as __BaseException } from "./EKSServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare const AddonIssueCode: {
  readonly ACCESS_DENIED: "AccessDenied";
  readonly ADMISSION_REQUEST_DENIED: "AdmissionRequestDenied";
  readonly CLUSTER_UNREACHABLE: "ClusterUnreachable";
  readonly CONFIGURATION_CONFLICT: "ConfigurationConflict";
  readonly INSUFFICIENT_NUMBER_OF_REPLICAS: "InsufficientNumberOfReplicas";
  readonly INTERNAL_FAILURE: "InternalFailure";
  readonly K8S_RESOURCE_NOT_FOUND: "K8sResourceNotFound";
  readonly UNSUPPORTED_ADDON_MODIFICATION: "UnsupportedAddonModification";
};
export type AddonIssueCode =
  (typeof AddonIssueCode)[keyof typeof AddonIssueCode];
export interface AddonIssue {
  code?: AddonIssueCode | string;
  message?: string;
  resourceIds?: string[];
}
export interface AddonHealth {
  issues?: AddonIssue[];
}
export interface MarketplaceInformation {
  productId?: string;
  productUrl?: string;
}
export declare const AddonStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATE_FAILED: "CREATE_FAILED";
  readonly CREATING: "CREATING";
  readonly DEGRADED: "DEGRADED";
  readonly DELETE_FAILED: "DELETE_FAILED";
  readonly DELETING: "DELETING";
  readonly UPDATE_FAILED: "UPDATE_FAILED";
  readonly UPDATING: "UPDATING";
};
export type AddonStatus = (typeof AddonStatus)[keyof typeof AddonStatus];
export interface Addon {
  addonName?: string;
  clusterName?: string;
  status?: AddonStatus | string;
  addonVersion?: string;
  health?: AddonHealth;
  addonArn?: string;
  createdAt?: Date;
  modifiedAt?: Date;
  serviceAccountRoleArn?: string;
  tags?: Record<string, string>;
  publisher?: string;
  owner?: string;
  marketplaceInformation?: MarketplaceInformation;
  configurationValues?: string;
}
export interface Compatibility {
  clusterVersion?: string;
  platformVersions?: string[];
  defaultVersion?: boolean;
}
export interface AddonVersionInfo {
  addonVersion?: string;
  architecture?: string[];
  compatibilities?: Compatibility[];
  requiresConfiguration?: boolean;
}
export interface AddonInfo {
  addonName?: string;
  type?: string;
  addonVersions?: AddonVersionInfo[];
  publisher?: string;
  owner?: string;
  marketplaceInformation?: MarketplaceInformation;
}
export declare const AMITypes: {
  readonly AL2_ARM_64: "AL2_ARM_64";
  readonly AL2_x86_64: "AL2_x86_64";
  readonly AL2_x86_64_GPU: "AL2_x86_64_GPU";
  readonly BOTTLEROCKET_ARM_64: "BOTTLEROCKET_ARM_64";
  readonly BOTTLEROCKET_ARM_64_NVIDIA: "BOTTLEROCKET_ARM_64_NVIDIA";
  readonly BOTTLEROCKET_x86_64: "BOTTLEROCKET_x86_64";
  readonly BOTTLEROCKET_x86_64_NVIDIA: "BOTTLEROCKET_x86_64_NVIDIA";
  readonly CUSTOM: "CUSTOM";
  readonly WINDOWS_CORE_2019_x86_64: "WINDOWS_CORE_2019_x86_64";
  readonly WINDOWS_CORE_2022_x86_64: "WINDOWS_CORE_2022_x86_64";
  readonly WINDOWS_FULL_2019_x86_64: "WINDOWS_FULL_2019_x86_64";
  readonly WINDOWS_FULL_2022_x86_64: "WINDOWS_FULL_2022_x86_64";
};
export type AMITypes = (typeof AMITypes)[keyof typeof AMITypes];
export interface Provider {
  keyArn?: string;
}
export interface EncryptionConfig {
  resources?: string[];
  provider?: Provider;
}
export interface AssociateEncryptionConfigRequest {
  clusterName: string | undefined;
  encryptionConfig: EncryptionConfig[] | undefined;
  clientRequestToken?: string;
}
export declare const ErrorCode: {
  readonly ACCESS_DENIED: "AccessDenied";
  readonly ADMISSION_REQUEST_DENIED: "AdmissionRequestDenied";
  readonly CLUSTER_UNREACHABLE: "ClusterUnreachable";
  readonly CONFIGURATION_CONFLICT: "ConfigurationConflict";
  readonly ENI_LIMIT_REACHED: "EniLimitReached";
  readonly INSUFFICIENT_FREE_ADDRESSES: "InsufficientFreeAddresses";
  readonly INSUFFICIENT_NUMBER_OF_REPLICAS: "InsufficientNumberOfReplicas";
  readonly IP_NOT_AVAILABLE: "IpNotAvailable";
  readonly K8S_RESOURCE_NOT_FOUND: "K8sResourceNotFound";
  readonly NODE_CREATION_FAILURE: "NodeCreationFailure";
  readonly OPERATION_NOT_PERMITTED: "OperationNotPermitted";
  readonly POD_EVICTION_FAILURE: "PodEvictionFailure";
  readonly SECURITY_GROUP_NOT_FOUND: "SecurityGroupNotFound";
  readonly SUBNET_NOT_FOUND: "SubnetNotFound";
  readonly UNKNOWN: "Unknown";
  readonly UNSUPPORTED_ADDON_MODIFICATION: "UnsupportedAddonModification";
  readonly VPC_ID_NOT_FOUND: "VpcIdNotFound";
};
export type ErrorCode = (typeof ErrorCode)[keyof typeof ErrorCode];
export interface ErrorDetail {
  errorCode?: ErrorCode | string;
  errorMessage?: string;
  resourceIds?: string[];
}
export declare const UpdateParamType: {
  readonly ADDON_VERSION: "AddonVersion";
  readonly CLUSTER_LOGGING: "ClusterLogging";
  readonly DESIRED_SIZE: "DesiredSize";
  readonly ENCRYPTION_CONFIG: "EncryptionConfig";
  readonly ENDPOINT_PRIVATE_ACCESS: "EndpointPrivateAccess";
  readonly ENDPOINT_PUBLIC_ACCESS: "EndpointPublicAccess";
  readonly IDENTITY_PROVIDER_CONFIG: "IdentityProviderConfig";
  readonly LABELS_TO_ADD: "LabelsToAdd";
  readonly LABELS_TO_REMOVE: "LabelsToRemove";
  readonly LAUNCH_TEMPLATE_NAME: "LaunchTemplateName";
  readonly LAUNCH_TEMPLATE_VERSION: "LaunchTemplateVersion";
  readonly MAX_SIZE: "MaxSize";
  readonly MAX_UNAVAILABLE: "MaxUnavailable";
  readonly MAX_UNAVAILABLE_PERCENTAGE: "MaxUnavailablePercentage";
  readonly MIN_SIZE: "MinSize";
  readonly PLATFORM_VERSION: "PlatformVersion";
  readonly PUBLIC_ACCESS_CIDRS: "PublicAccessCidrs";
  readonly RELEASE_VERSION: "ReleaseVersion";
  readonly RESOLVE_CONFLICTS: "ResolveConflicts";
  readonly SERVICE_ACCOUNT_ROLE_ARN: "ServiceAccountRoleArn";
  readonly TAINTS_TO_ADD: "TaintsToAdd";
  readonly TAINTS_TO_REMOVE: "TaintsToRemove";
  readonly VERSION: "Version";
};
export type UpdateParamType =
  (typeof UpdateParamType)[keyof typeof UpdateParamType];
export interface UpdateParam {
  type?: UpdateParamType | string;
  value?: string;
}
export declare const UpdateStatus: {
  readonly CANCELLED: "Cancelled";
  readonly FAILED: "Failed";
  readonly IN_PROGRESS: "InProgress";
  readonly SUCCESSFUL: "Successful";
};
export type UpdateStatus = (typeof UpdateStatus)[keyof typeof UpdateStatus];
export declare const UpdateType: {
  readonly ADDON_UPDATE: "AddonUpdate";
  readonly ASSOCIATE_ENCRYPTION_CONFIG: "AssociateEncryptionConfig";
  readonly ASSOCIATE_IDENTITY_PROVIDER_CONFIG: "AssociateIdentityProviderConfig";
  readonly CONFIG_UPDATE: "ConfigUpdate";
  readonly DISASSOCIATE_IDENTITY_PROVIDER_CONFIG: "DisassociateIdentityProviderConfig";
  readonly ENDPOINT_ACCESS_UPDATE: "EndpointAccessUpdate";
  readonly LOGGING_UPDATE: "LoggingUpdate";
  readonly VERSION_UPDATE: "VersionUpdate";
};
export type UpdateType = (typeof UpdateType)[keyof typeof UpdateType];
export interface Update {
  id?: string;
  status?: UpdateStatus | string;
  type?: UpdateType | string;
  params?: UpdateParam[];
  createdAt?: Date;
  errors?: ErrorDetail[];
}
export interface AssociateEncryptionConfigResponse {
  update?: Update;
}
export declare class ClientException extends __BaseException {
  readonly name: "ClientException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  addonName?: string;
  constructor(opts: __ExceptionOptionType<ClientException, __BaseException>);
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  fargateProfileName?: string;
  addonName?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class InvalidRequestException extends __BaseException {
  readonly name: "InvalidRequestException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  addonName?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidRequestException, __BaseException>
  );
}
export declare class ResourceInUseException extends __BaseException {
  readonly name: "ResourceInUseException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  addonName?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceInUseException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  fargateProfileName?: string;
  addonName?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ServerException extends __BaseException {
  readonly name: "ServerException";
  readonly $fault: "server";
  clusterName?: string;
  nodegroupName?: string;
  addonName?: string;
  constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
}
export interface OidcIdentityProviderConfigRequest {
  identityProviderConfigName: string | undefined;
  issuerUrl: string | undefined;
  clientId: string | undefined;
  usernameClaim?: string;
  usernamePrefix?: string;
  groupsClaim?: string;
  groupsPrefix?: string;
  requiredClaims?: Record<string, string>;
}
export interface AssociateIdentityProviderConfigRequest {
  clusterName: string | undefined;
  oidc: OidcIdentityProviderConfigRequest | undefined;
  tags?: Record<string, string>;
  clientRequestToken?: string;
}
export interface AssociateIdentityProviderConfigResponse {
  update?: Update;
  tags?: Record<string, string>;
}
export interface AutoScalingGroup {
  name?: string;
}
export declare const ResolveConflicts: {
  readonly NONE: "NONE";
  readonly OVERWRITE: "OVERWRITE";
  readonly PRESERVE: "PRESERVE";
};
export type ResolveConflicts =
  (typeof ResolveConflicts)[keyof typeof ResolveConflicts];
export interface CreateAddonRequest {
  clusterName: string | undefined;
  addonName: string | undefined;
  addonVersion?: string;
  serviceAccountRoleArn?: string;
  resolveConflicts?: ResolveConflicts | string;
  clientRequestToken?: string;
  tags?: Record<string, string>;
  configurationValues?: string;
}
export interface CreateAddonResponse {
  addon?: Addon;
}
export declare const IpFamily: {
  readonly IPV4: "ipv4";
  readonly IPV6: "ipv6";
};
export type IpFamily = (typeof IpFamily)[keyof typeof IpFamily];
export interface KubernetesNetworkConfigRequest {
  serviceIpv4Cidr?: string;
  ipFamily?: IpFamily | string;
}
export declare const LogType: {
  readonly API: "api";
  readonly AUDIT: "audit";
  readonly AUTHENTICATOR: "authenticator";
  readonly CONTROLLER_MANAGER: "controllerManager";
  readonly SCHEDULER: "scheduler";
};
export type LogType = (typeof LogType)[keyof typeof LogType];
export interface LogSetup {
  types?: (LogType | string)[];
  enabled?: boolean;
}
export interface Logging {
  clusterLogging?: LogSetup[];
}
export interface ControlPlanePlacementRequest {
  groupName?: string;
}
export interface OutpostConfigRequest {
  outpostArns: string[] | undefined;
  controlPlaneInstanceType: string | undefined;
  controlPlanePlacement?: ControlPlanePlacementRequest;
}
export interface VpcConfigRequest {
  subnetIds?: string[];
  securityGroupIds?: string[];
  endpointPublicAccess?: boolean;
  endpointPrivateAccess?: boolean;
  publicAccessCidrs?: string[];
}
export interface CreateClusterRequest {
  name: string | undefined;
  version?: string;
  roleArn: string | undefined;
  resourcesVpcConfig: VpcConfigRequest | undefined;
  kubernetesNetworkConfig?: KubernetesNetworkConfigRequest;
  logging?: Logging;
  clientRequestToken?: string;
  tags?: Record<string, string>;
  encryptionConfig?: EncryptionConfig[];
  outpostConfig?: OutpostConfigRequest;
}
export interface Certificate {
  data?: string;
}
export interface ConnectorConfigResponse {
  activationId?: string;
  activationCode?: string;
  activationExpiry?: Date;
  provider?: string;
  roleArn?: string;
}
export declare const ClusterIssueCode: {
  readonly ACCESS_DENIED: "AccessDenied";
  readonly CLUSTER_UNREACHABLE: "ClusterUnreachable";
  readonly CONFIGURATION_CONFLICT: "ConfigurationConflict";
  readonly INTERNAL_FAILURE: "InternalFailure";
  readonly RESOURCE_LIMIT_EXCEEDED: "ResourceLimitExceeded";
  readonly RESOURCE_NOT_FOUND: "ResourceNotFound";
};
export type ClusterIssueCode =
  (typeof ClusterIssueCode)[keyof typeof ClusterIssueCode];
export interface ClusterIssue {
  code?: ClusterIssueCode | string;
  message?: string;
  resourceIds?: string[];
}
export interface ClusterHealth {
  issues?: ClusterIssue[];
}
export interface OIDC {
  issuer?: string;
}
export interface Identity {
  oidc?: OIDC;
}
export interface KubernetesNetworkConfigResponse {
  serviceIpv4Cidr?: string;
  serviceIpv6Cidr?: string;
  ipFamily?: IpFamily | string;
}
export interface ControlPlanePlacementResponse {
  groupName?: string;
}
export interface OutpostConfigResponse {
  outpostArns: string[] | undefined;
  controlPlaneInstanceType: string | undefined;
  controlPlanePlacement?: ControlPlanePlacementResponse;
}
export interface VpcConfigResponse {
  subnetIds?: string[];
  securityGroupIds?: string[];
  clusterSecurityGroupId?: string;
  vpcId?: string;
  endpointPublicAccess?: boolean;
  endpointPrivateAccess?: boolean;
  publicAccessCidrs?: string[];
}
export declare const ClusterStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATING: "CREATING";
  readonly DELETING: "DELETING";
  readonly FAILED: "FAILED";
  readonly PENDING: "PENDING";
  readonly UPDATING: "UPDATING";
};
export type ClusterStatus = (typeof ClusterStatus)[keyof typeof ClusterStatus];
export interface Cluster {
  name?: string;
  arn?: string;
  createdAt?: Date;
  version?: string;
  endpoint?: string;
  roleArn?: string;
  resourcesVpcConfig?: VpcConfigResponse;
  kubernetesNetworkConfig?: KubernetesNetworkConfigResponse;
  logging?: Logging;
  identity?: Identity;
  status?: ClusterStatus | string;
  certificateAuthority?: Certificate;
  clientRequestToken?: string;
  platformVersion?: string;
  tags?: Record<string, string>;
  encryptionConfig?: EncryptionConfig[];
  connectorConfig?: ConnectorConfigResponse;
  id?: string;
  health?: ClusterHealth;
  outpostConfig?: OutpostConfigResponse;
}
export interface CreateClusterResponse {
  cluster?: Cluster;
}
export declare class ResourceLimitExceededException extends __BaseException {
  readonly name: "ResourceLimitExceededException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceLimitExceededException, __BaseException>
  );
}
export declare class ServiceUnavailableException extends __BaseException {
  readonly name: "ServiceUnavailableException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>
  );
}
export declare class UnsupportedAvailabilityZoneException extends __BaseException {
  readonly name: "UnsupportedAvailabilityZoneException";
  readonly $fault: "client";
  clusterName?: string;
  nodegroupName?: string;
  validZones?: string[];
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedAvailabilityZoneException,
      __BaseException
    >
  );
}
export interface FargateProfileSelector {
  namespace?: string;
  labels?: Record<string, string>;
}
export interface CreateFargateProfileRequest {
  fargateProfileName: string | undefined;
  clusterName: string | undefined;
  podExecutionRoleArn: string | undefined;
  subnets?: string[];
  selectors?: FargateProfileSelector[];
  clientRequestToken?: string;
  tags?: Record<string, string>;
}
export declare const FargateProfileStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATE_FAILED: "CREATE_FAILED";
  readonly CREATING: "CREATING";
  readonly DELETE_FAILED: "DELETE_FAILED";
  readonly DELETING: "DELETING";
};
export type FargateProfileStatus =
  (typeof FargateProfileStatus)[keyof typeof FargateProfileStatus];
export interface FargateProfile {
  fargateProfileName?: string;
  fargateProfileArn?: string;
  clusterName?: string;
  createdAt?: Date;
  podExecutionRoleArn?: string;
  subnets?: string[];
  selectors?: FargateProfileSelector[];
  status?: FargateProfileStatus | string;
  tags?: Record<string, string>;
}
export interface CreateFargateProfileResponse {
  fargateProfile?: FargateProfile;
}
export declare const CapacityTypes: {
  readonly ON_DEMAND: "ON_DEMAND";
  readonly SPOT: "SPOT";
};
export type CapacityTypes = (typeof CapacityTypes)[keyof typeof CapacityTypes];
export interface LaunchTemplateSpecification {
  name?: string;
  version?: string;
  id?: string;
}
export interface RemoteAccessConfig {
  ec2SshKey?: string;
  sourceSecurityGroups?: string[];
}
export interface NodegroupScalingConfig {
  minSize?: number;
  maxSize?: number;
  desiredSize?: number;
}
export declare const TaintEffect: {
  readonly NO_EXECUTE: "NO_EXECUTE";
  readonly NO_SCHEDULE: "NO_SCHEDULE";
  readonly PREFER_NO_SCHEDULE: "PREFER_NO_SCHEDULE";
};
export type TaintEffect = (typeof TaintEffect)[keyof typeof TaintEffect];
export interface Taint {
  key?: string;
  value?: string;
  effect?: TaintEffect | string;
}
export interface NodegroupUpdateConfig {
  maxUnavailable?: number;
  maxUnavailablePercentage?: number;
}
export interface CreateNodegroupRequest {
  clusterName: string | undefined;
  nodegroupName: string | undefined;
  scalingConfig?: NodegroupScalingConfig;
  diskSize?: number;
  subnets: string[] | undefined;
  instanceTypes?: string[];
  amiType?: AMITypes | string;
  remoteAccess?: RemoteAccessConfig;
  nodeRole: string | undefined;
  labels?: Record<string, string>;
  taints?: Taint[];
  tags?: Record<string, string>;
  clientRequestToken?: string;
  launchTemplate?: LaunchTemplateSpecification;
  updateConfig?: NodegroupUpdateConfig;
  capacityType?: CapacityTypes | string;
  version?: string;
  releaseVersion?: string;
}
export declare const NodegroupIssueCode: {
  readonly ACCESS_DENIED: "AccessDenied";
  readonly ASG_INSTANCE_LAUNCH_FAILURES: "AsgInstanceLaunchFailures";
  readonly AUTO_SCALING_GROUP_INVALID_CONFIGURATION: "AutoScalingGroupInvalidConfiguration";
  readonly AUTO_SCALING_GROUP_NOT_FOUND: "AutoScalingGroupNotFound";
  readonly CLUSTER_UNREACHABLE: "ClusterUnreachable";
  readonly EC2_LAUNCH_TEMPLATE_NOT_FOUND: "Ec2LaunchTemplateNotFound";
  readonly EC2_LAUNCH_TEMPLATE_VERSION_MISMATCH: "Ec2LaunchTemplateVersionMismatch";
  readonly EC2_SECURITY_GROUP_DELETION_FAILURE: "Ec2SecurityGroupDeletionFailure";
  readonly EC2_SECURITY_GROUP_NOT_FOUND: "Ec2SecurityGroupNotFound";
  readonly EC2_SUBNET_INVALID_CONFIGURATION: "Ec2SubnetInvalidConfiguration";
  readonly EC2_SUBNET_MISSING_IPV6_ASSIGNMENT: "Ec2SubnetMissingIpv6Assignment";
  readonly EC2_SUBNET_NOT_FOUND: "Ec2SubnetNotFound";
  readonly IAM_INSTANCE_PROFILE_NOT_FOUND: "IamInstanceProfileNotFound";
  readonly IAM_LIMIT_EXCEEDED: "IamLimitExceeded";
  readonly IAM_NODE_ROLE_NOT_FOUND: "IamNodeRoleNotFound";
  readonly INSTANCE_LIMIT_EXCEEDED: "InstanceLimitExceeded";
  readonly INSUFFICIENT_FREE_ADDRESSES: "InsufficientFreeAddresses";
  readonly INTERNAL_FAILURE: "InternalFailure";
  readonly NODE_CREATION_FAILURE: "NodeCreationFailure";
};
export type NodegroupIssueCode =
  (typeof NodegroupIssueCode)[keyof typeof NodegroupIssueCode];
export interface Issue {
  code?: NodegroupIssueCode | string;
  message?: string;
  resourceIds?: string[];
}
export interface NodegroupHealth {
  issues?: Issue[];
}
export interface NodegroupResources {
  autoScalingGroups?: AutoScalingGroup[];
  remoteAccessSecurityGroup?: string;
}
export declare const NodegroupStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATE_FAILED: "CREATE_FAILED";
  readonly CREATING: "CREATING";
  readonly DEGRADED: "DEGRADED";
  readonly DELETE_FAILED: "DELETE_FAILED";
  readonly DELETING: "DELETING";
  readonly UPDATING: "UPDATING";
};
export type NodegroupStatus =
  (typeof NodegroupStatus)[keyof typeof NodegroupStatus];
export interface Nodegroup {
  nodegroupName?: string;
  nodegroupArn?: string;
  clusterName?: string;
  version?: string;
  releaseVersion?: string;
  createdAt?: Date;
  modifiedAt?: Date;
  status?: NodegroupStatus | string;
  capacityType?: CapacityTypes | string;
  scalingConfig?: NodegroupScalingConfig;
  instanceTypes?: string[];
  subnets?: string[];
  remoteAccess?: RemoteAccessConfig;
  amiType?: AMITypes | string;
  nodeRole?: string;
  labels?: Record<string, string>;
  taints?: Taint[];
  resources?: NodegroupResources;
  diskSize?: number;
  health?: NodegroupHealth;
  updateConfig?: NodegroupUpdateConfig;
  launchTemplate?: LaunchTemplateSpecification;
  tags?: Record<string, string>;
}
export interface CreateNodegroupResponse {
  nodegroup?: Nodegroup;
}
export interface DeleteAddonRequest {
  clusterName: string | undefined;
  addonName: string | undefined;
  preserve?: boolean;
}
export interface DeleteAddonResponse {
  addon?: Addon;
}
export interface DeleteClusterRequest {
  name: string | undefined;
}
export interface DeleteClusterResponse {
  cluster?: Cluster;
}
export interface DeleteFargateProfileRequest {
  clusterName: string | undefined;
  fargateProfileName: string | undefined;
}
export interface DeleteFargateProfileResponse {
  fargateProfile?: FargateProfile;
}
export interface DeleteNodegroupRequest {
  clusterName: string | undefined;
  nodegroupName: string | undefined;
}
export interface DeleteNodegroupResponse {
  nodegroup?: Nodegroup;
}
export interface DeregisterClusterRequest {
  name: string | undefined;
}
export interface DeregisterClusterResponse {
  cluster?: Cluster;
}
export interface DescribeAddonRequest {
  clusterName: string | undefined;
  addonName: string | undefined;
}
export interface DescribeAddonResponse {
  addon?: Addon;
}
export interface DescribeAddonConfigurationRequest {
  addonName: string | undefined;
  addonVersion: string | undefined;
}
export interface DescribeAddonConfigurationResponse {
  addonName?: string;
  addonVersion?: string;
  configurationSchema?: string;
}
export interface DescribeAddonVersionsRequest {
  kubernetesVersion?: string;
  maxResults?: number;
  nextToken?: string;
  addonName?: string;
  types?: string[];
  publishers?: string[];
  owners?: string[];
}
export interface DescribeAddonVersionsResponse {
  addons?: AddonInfo[];
  nextToken?: string;
}
export interface DescribeClusterRequest {
  name: string | undefined;
}
export interface DescribeClusterResponse {
  cluster?: Cluster;
}
export interface DescribeFargateProfileRequest {
  clusterName: string | undefined;
  fargateProfileName: string | undefined;
}
export interface DescribeFargateProfileResponse {
  fargateProfile?: FargateProfile;
}
export interface IdentityProviderConfig {
  type: string | undefined;
  name: string | undefined;
}
export interface DescribeIdentityProviderConfigRequest {
  clusterName: string | undefined;
  identityProviderConfig: IdentityProviderConfig | undefined;
}
export declare const ConfigStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATING: "CREATING";
  readonly DELETING: "DELETING";
};
export type ConfigStatus = (typeof ConfigStatus)[keyof typeof ConfigStatus];
export interface OidcIdentityProviderConfig {
  identityProviderConfigName?: string;
  identityProviderConfigArn?: string;
  clusterName?: string;
  issuerUrl?: string;
  clientId?: string;
  usernameClaim?: string;
  usernamePrefix?: string;
  groupsClaim?: string;
  groupsPrefix?: string;
  requiredClaims?: Record<string, string>;
  tags?: Record<string, string>;
  status?: ConfigStatus | string;
}
export interface IdentityProviderConfigResponse {
  oidc?: OidcIdentityProviderConfig;
}
export interface DescribeIdentityProviderConfigResponse {
  identityProviderConfig?: IdentityProviderConfigResponse;
}
export interface DescribeNodegroupRequest {
  clusterName: string | undefined;
  nodegroupName: string | undefined;
}
export interface DescribeNodegroupResponse {
  nodegroup?: Nodegroup;
}
export interface DescribeUpdateRequest {
  name: string | undefined;
  updateId: string | undefined;
  nodegroupName?: string;
  addonName?: string;
}
export interface DescribeUpdateResponse {
  update?: Update;
}
export interface DisassociateIdentityProviderConfigRequest {
  clusterName: string | undefined;
  identityProviderConfig: IdentityProviderConfig | undefined;
  clientRequestToken?: string;
}
export interface DisassociateIdentityProviderConfigResponse {
  update?: Update;
}
export interface ListAddonsRequest {
  clusterName: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ListAddonsResponse {
  addons?: string[];
  nextToken?: string;
}
export interface ListClustersRequest {
  maxResults?: number;
  nextToken?: string;
  include?: string[];
}
export interface ListClustersResponse {
  clusters?: string[];
  nextToken?: string;
}
export interface ListFargateProfilesRequest {
  clusterName: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ListFargateProfilesResponse {
  fargateProfileNames?: string[];
  nextToken?: string;
}
export interface ListIdentityProviderConfigsRequest {
  clusterName: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ListIdentityProviderConfigsResponse {
  identityProviderConfigs?: IdentityProviderConfig[];
  nextToken?: string;
}
export interface ListNodegroupsRequest {
  clusterName: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ListNodegroupsResponse {
  nodegroups?: string[];
  nextToken?: string;
}
export declare class BadRequestException extends __BaseException {
  readonly name: "BadRequestException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<BadRequestException, __BaseException>
  );
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Record<string, string>;
}
export declare class NotFoundException extends __BaseException {
  readonly name: "NotFoundException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
}
export interface ListUpdatesRequest {
  name: string | undefined;
  nodegroupName?: string;
  addonName?: string;
  nextToken?: string;
  maxResults?: number;
}
export interface ListUpdatesResponse {
  updateIds?: string[];
  nextToken?: string;
}
export declare const ConnectorConfigProvider: {
  readonly AKS: "AKS";
  readonly ANTHOS: "ANTHOS";
  readonly EC2: "EC2";
  readonly EKS_ANYWHERE: "EKS_ANYWHERE";
  readonly GKE: "GKE";
  readonly OPENSHIFT: "OPENSHIFT";
  readonly OTHER: "OTHER";
  readonly RANCHER: "RANCHER";
  readonly TANZU: "TANZU";
};
export type ConnectorConfigProvider =
  (typeof ConnectorConfigProvider)[keyof typeof ConnectorConfigProvider];
export interface ConnectorConfigRequest {
  roleArn: string | undefined;
  provider: ConnectorConfigProvider | string | undefined;
}
export interface RegisterClusterRequest {
  name: string | undefined;
  connectorConfig: ConnectorConfigRequest | undefined;
  clientRequestToken?: string;
  tags?: Record<string, string>;
}
export interface RegisterClusterResponse {
  cluster?: Cluster;
}
export declare class ResourcePropagationDelayException extends __BaseException {
  readonly name: "ResourcePropagationDelayException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ResourcePropagationDelayException,
      __BaseException
    >
  );
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export interface UpdateAddonRequest {
  clusterName: string | undefined;
  addonName: string | undefined;
  addonVersion?: string;
  serviceAccountRoleArn?: string;
  resolveConflicts?: ResolveConflicts | string;
  clientRequestToken?: string;
  configurationValues?: string;
}
export interface UpdateAddonResponse {
  update?: Update;
}
export interface UpdateClusterConfigRequest {
  name: string | undefined;
  resourcesVpcConfig?: VpcConfigRequest;
  logging?: Logging;
  clientRequestToken?: string;
}
export interface UpdateClusterConfigResponse {
  update?: Update;
}
export interface UpdateClusterVersionRequest {
  name: string | undefined;
  version: string | undefined;
  clientRequestToken?: string;
}
export interface UpdateClusterVersionResponse {
  update?: Update;
}
export interface UpdateLabelsPayload {
  addOrUpdateLabels?: Record<string, string>;
  removeLabels?: string[];
}
export interface UpdateTaintsPayload {
  addOrUpdateTaints?: Taint[];
  removeTaints?: Taint[];
}
export interface UpdateNodegroupConfigRequest {
  clusterName: string | undefined;
  nodegroupName: string | undefined;
  labels?: UpdateLabelsPayload;
  taints?: UpdateTaintsPayload;
  scalingConfig?: NodegroupScalingConfig;
  updateConfig?: NodegroupUpdateConfig;
  clientRequestToken?: string;
}
export interface UpdateNodegroupConfigResponse {
  update?: Update;
}
export interface UpdateNodegroupVersionRequest {
  clusterName: string | undefined;
  nodegroupName: string | undefined;
  version?: string;
  releaseVersion?: string;
  launchTemplate?: LaunchTemplateSpecification;
  force?: boolean;
  clientRequestToken?: string;
}
export interface UpdateNodegroupVersionResponse {
  update?: Update;
}
